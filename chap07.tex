ここまでに紹介したような方法で十分な水準の通信を確立できる状況となった。しかしながら、どの方法を取るにせよ何らかの事情で通信に誤りが起こることは避けきれない。そこで、通信において正確性を担保するために、誤りを検知して対処するための\textbf{誤り制御}\index{あやまりせぎいぎょ@誤り制御}(error control)の手法がある。今回はこの誤り制御について紹介していく。

\section{誤り制御}

人間が直接声でやり取りをする際に、不明瞭な発音等により意図が正確に伝わらないことは往々にして起こりうる。例えば、数字の1と7はそれぞれ「いち」「しち」と読むわけだが、文脈からどちらかの判断がつかないようなケースでは聞き間違えは致命的となりうる。「1時からの番組の録画予約をお願いします」と伝えたときに、7時から録画されてしまうと見たい番組が見られない。同じように、アルファベットを伝えるシーンでもb,d,pなどは読みが似ているため、メールアドレスを口頭で連絡するなどの必要があるときには、誤りに注意するであろう。

このように、人間同士が声でやり取りする際に誤りが懸念される場合には、予め対処を取るだろう。簡単な例を挙げると
\begin{itemize}
\item わかりやすいように言い換える：「しち」でなく「なな」、「でぃー」でなく「でー」
\item 通話表を使う：いろはの「い」、Bravoの「b」
\item 復唱して確かめる
\item 文脈を付け加えて確認する：「1時からの〇〇という番組？」
\end{itemize}
などは、誤りなく伝えるための手法と言える。そして、これにより誤りが見つかった場合、相手から正しい情報を再度聞き出すなり、明らかに別とわかるなら自分で考えて修正するなりして誤りをなくす。

通信においても、例えば電圧の都合などでビットが不明瞭である\footnote{例えば、CDであればレーザー刻印が十分深くない、電圧がそもそも境界値周辺で振動しているなど。逆に、前者のような刻印をあえて作ってコピーガードとしている例もある。}、雑音が入った、機器の特性など、様々な事情で誤りが起こりうる。これらの対処を行うのが誤り制御である。とりわけ、致命的な過誤を防ぐためにも、誤り制御は重要と言える。とはいえ、誤り制御にあまり大きなリソースを割くのは難しい。先の人間の例であっても、「1時からの番組の録画予約をお願いします」の、1と7以外の場所の誤りを逐一チェックする(「からの」じゃなくて「までの」ではないか、「録画」でなくて「録音」ではないか、「お願いします」ではなく「お願いしません」ではないか…など)ようなことは普通やらない。つまり、誤り制御には次のような性質が求められる。
\begin{itembox}[l]{誤り制御に求められる性質}
\begin{itemize}
\item 誤りを十分に高い確率(100\%とまでは言えなくてもそれに限りなく近い確率)で検知できること。
\item 大幅なリソースを要しないこと。
\item 誤り制御に関する情報自体に誤りが含まれる可能性を考慮すること。また、その誤りが少ない程度に簡潔な情報であること。
\end{itemize}
\end{itembox}

この性質を満たすような手法を用意し、誤りを検出すれば、後はこれを訂正するだけである。人間の例でわかるとおり、訂正方法は「相手に訂正してもらう(再送してもらう)」か「自分で訂正する(訂正できるだけの情報をもらっておく)」のいずれかである。前者のように、誤りを検出するだけして、誤った場合に再送してもらう方法を\textbf{帰還方式}\index{きかんほうしき@帰還方式}(\textbf{ARQ}\index{ARQ|see{ARQ}},Automatic Repeat reQuest)といい、これに使う符号を\textbf{誤り検出符号}\index{あやまりけんしゅつふごう@誤り検出符号}と呼ぶ。一方、後者のように、誤りを検出すると共にその情報から訂正まで行う方式を\textbf{無帰還方式}\index{むきかんほうしき@無帰還方式}(\textbf{FEC}\index{FEC|see{FEC}},Forward Error Control)といい、これに使う符号を\textbf{誤り訂正符号}\index{あやまりていせいふごう@誤り訂正符号}と呼ぶ。

\subsection{誤り制御の簡単な例}

極めて単純な誤り制御の例を3つほどあげてみよう。ファイルをダウンロードする場合を考える。この時、正確なファイルがダウンロードされたかどうかを確認したい。

最も単純な方法として、そのファイルを複数個ダウンロードし、ビット別に比較するという方法が考えられる。十分な数のファイルをダウンロードし、多数決で各ビットを定めていけば(エラー率が十分低い=伝送基準が十分高い前提の下)正しいファイルが出来上がるだろう。しかし、この方法は本来一つで良いはずのファイルを何度もダウンロードしなければならず、例えばOSのisoファイルなどサイズの大きいファイルを対象とした場合にリソースを大幅に食ってしまう。

そこで、ファイル自体に関するデータを確認するという手法がある。例えば、ファイルサイズが本来のサイズとバイト単位で一致するかどうか確認するのである。バイト単位で一致しなければ過剰あるいは不足があり、明らかに正しいデータではないから、再ダウンロードを行う。この手法はやり取りするデータがごく小さいことからリソースが守られるが、同一サイズでビットが変わっているという（起こりえそうな）ケースには無力である。

他には、ファイル・フォーマットを確かめるという手法がある。マニアックな域ならバイナリを見るような人もいるかもしれないが、最も簡単な方法ならそのファイル自体を開ける状態にして開いてみる。ソフトウェアなら動作させればいいし、isoならマウントするなりディスクに焼くなりする。動画や音声なら再生してみれば良い。このとき、正しく開ければおそらく間違ってはいないだろう。この手法は、通信に関するリソースを要求しないが、開く側でのリソースは決して少なくない。また、サーバに搭載するソフトなど、気楽に試せるものばかりでもない。

ここで挙げた例はいずれも誤り制御であるが、それぞれにリソースや検出できる誤りに違いがある。多くの場合、誤り制御はリソースと対処率のトレードオフと言ってよい。このトレードオフの中で、様々な誤り制御手法が生まれてきた。この後は、順次それを紹介していく。
\section{誤り検出符号}
誤り検出符号は誤り訂正符号よりも通常小回りが利く(サイズが小さい・アルゴリズムが速いなど)ものが多いため、現実的な通信もこちらの方式を採用する場合が多い。また、誤り訂正符号と違い、誤っているかどうかがわかれば対処できるため(後述するが、誤り訂正符号は1ビットまでの誤りなら対応できるがそれ以上は対応できないなどの限界がある)、誤りの状況によらない(通信の輻輳等により発生する集中的な誤り(バースト誤り)にも、散発的に発生する単独の誤り(ランダム誤り)にも対応する)という利点もある。

以下、誤り検出符号の何種類かの方式について記す。

\subsection{パリティビット}
データを送る際に、区切りごとの偶奇(パリティ)を定めてビットを付加してデータを送信する方法ならびにその際に付加するビットを\textbf{パリティビット}\index{ぱりてぃびっと@パリティビット}と呼ぶ。これによる誤り検出は\textbf{パリティチェック}\index{ぱりてぃちぇっく@パリティチェック}という。

最もよくあるケースでは、実データ7bit毎にパリティビット1bitを加え、1byte毎のパリティを一定にするようにする。1byte毎のパリティとは、単純にデータ中の1の個数の偶奇である。例えば、1byte毎に偶数になるようなパリティビットを付加する場合、1110001や1110111のように1が偶数個ある実データには0を付加するし、1100100や1111111のように1が奇数個ある実データには1を付加する。受信側は、1byte毎に1の個数を数え、これが奇数である場合は再送を要求する。

もちろん、偶奇が同じ場合には誤りと判断されないので、2bit・4bit等、偶数個のbitに誤りがあった場合には検出できない。また、7bitに1bitをつける場合は元のデータの7分の8のデータとなり、15\%弱のデータ肥大化となる。

\subsubsection{【補遺】パリティチェックの実送信サイズ}
先にデータ肥大化を15\%弱と書いたが、これはデータの再送分などを考慮しておらず、単純に送信すべきデータの量を見た場合である。この補遺では、パリティチェックを行う場合、再送分なども含めて実送信サイズがどれぐらいになるのか(再送要求は十分無視できるサイズとして)考えてみる。

bit毎の誤り率を$p$とし、$n-1$bit毎にパリティビットを付加して$n$bit毎にデータが区切られるものとする。今、検出できる誤りである、奇数個の誤りが起きる確率$P_\mathrm{err}$\footnote{偶数個のエラーが出る場合は検出されないため無視している。}は
\begin{equation}
P_\mathrm{err}=\sum^{n/2}_{i=1} p^{2i-1} (1-p)^{n-2i+1} {}_n\mathrm{C}_{(2i-1)}
\end{equation}
により与えられる。ここで、検出できる誤りの起きる確率とは再送確率であることに注意する。再送が$k$回必要な確率$P_k$は
\begin{equation}
P_k = P_\mathrm{err}^{k} (1-P_\mathrm{err})
\end{equation}
で与えられる。したがって1データ区切り毎の送信回数(=1+送信回数)の期待値$E$は
\begin{equation}
E=\sum^{\infty}_{k=0} (k+1)P_k
\end{equation}
となる。ここで、$P_k$は$P_\mathrm{err}$を公比とする等比数列であり、当然$|P_\mathrm{err}|<1$であるのでこの無限等比級数は収束する。これをもとに計算すると
\begin{equation}
E=\frac{1}{(1-P_\mathrm{err})}
\end{equation}
となる。したがって、再送を平均して$\frac{n}{(1-P_\mathrm{err})}$bitの送信を行うこととなる。元のデータのサイズは区切り毎に$n-1$bitであるから、倍率でいえば$\frac{n}{(n-1)(1-P_\mathrm{err})}$倍のデータサイズとなる。

\subsection{チェックディジット}
符号だけでなく、実データにもよく使われる方法として、\textbf{チェックディジット}\index{ちぇっくでぃじっと@チェックディジット}と呼ばれる方法がある。パスワードやISBNなどにしばしば使われる。

チェックディジットは、データの区切り毎に（通常、そのデータを整数値とみて）何らかの計算を行い、その値を区切り毎に置くという手法である。（適当な計算が1の個数の偶奇であり、それに一致する値を置くという場合はパリティビットそのものになる。)ただし、チェックディジットは通常ビットレベルではなく、もう少し大きな単位で行われることが多い。

チェックディジットは「適当な計算」によりさまざまな種類がある（ゲームのデータ等の場合、独自形式のものも存在する）。ここでは、代表的なものを紹介しておく。
% https://qiita.com/yoshi389111/items/00ca7b3ed9ceac904cde
\subsubsection{DR型・DSR型}
DR(Division Remainder)型のチェックディジットは、数値をある値で割った剰余を付加する方法である。値としては、7や9がよく使われ、7DRや9DRと表記する。また、各々後述の7DSRや9DSRと合わせて、セブンチェックやナインチェックと呼ぶ。

元データが9876543だったとする。このときこれを7で割った余りは5、9で割った余りは6である。したがって、7DRの場合98765435というデータを、9DRの場合98765436というデータを送ることになる(チェックディジットを末尾においた)。

また、余りそのものではなく、割る値に対する基数の補数を付す場合もあり、これをDSR(Divide Subtract Remainder)型と呼ぶ。先の例9876543について、7DSRでチェックディジットを付加すると(7-5=2であるため)98765432となり、9DSRだと98765433となる。

運送会社の伝票番号には7DRが使われている。

\subsubsection{モジュラス・ウェイト型}
モジュラス・ウェイト型は、元の10進整数の各桁に適当な重み(ウェイト)をかけた総和をとり（このときウェイトをかけた時点で2桁以上の数が出た場合に、総和をそのままとる場合は一括方式、桁和を用いる場合分割方式と呼ぶ）、別の値での剰余の補数をとってチェックディジットとする方式である。チェックディジットが2桁になる場合は0にする場合が多い。

具体例として、モジュラス11ウェイト2$\sim$7を用いる、マイナンバーや住民票コード、運転免許証番号で用いられる手法を見てみよう。この方式は、次の手法でチェックディジットを決定する。
\begin{enumerate}
\item 数値の各桁に、下の桁から順に2,3,4,$cdots$,7の係数をかける。(おさまらない場合はまた$2$に戻る。つまり、7桁目には2を、8桁目には3を$\cdots$という風にかける)
\item 各桁の結果の総和を求め、これを11で割った剰余を求める。
\item 求めた剰余を11から引き(=補数を求め)、これをチェックディジットとする。ただし、10以上になる場合はチェックディジットを0とする。
\end{enumerate}

試しに、この方式で123456789のチェックディジットを求めてみよう。各桁の値と重み、その積は次のようになる。
\begin{center}
\begin{tabular}{c|ccccccccc}
桁&1&2&3&4&5&6&7&8&9 \\ 
重み&4&3&2&7&6&5&4&3&2 \\ \hline
桁$\times$重み&4&6&6&28&30&30&28&24&18 \\ 
\end{tabular}
\end{center}
一番下の桁$\times$重みの総和を求めると174となる。これを11で割った剰余は9であるので、チェックディジットは11-9=2となる。このチェックディジットを最終桁につけると1234567899となる。

マイナンバーの場合は11桁の数にこれを適用したものを末尾につけて12桁に、免許証番号の場合は最初の10桁にこれを適用したものをつけて11桁、最後に再発行の回数をつけて12桁としている。


さて、先の例は一括方式であったが、分割方式のものもある。クレジットカードなどで使われるモジュラス10ウェイト2・1分割方式は、次のような手順でチェックディジットを決定する。
\begin{enumerate}
\item 数値の各桁に、下の桁から順に2・1の係数をかける。(おさまらない場合はまた3に戻る。つまり、3桁目には2を、4桁目には1を$\cdots$という風にかける)
\item 掛けた値が2桁になった場合は、その十の位の数と一の位の数を足したものを用いる。(分割)
\item 各桁の結果の総和を求め、これを10で割った剰余を求める。
\item 求めた剰余を10から引き(=補数を求め)、これをチェックディジットとする。ただし、10になる場合はチェックディジットを0とする。
\end{enumerate}

この方式で今度は31415926のチェックディジットを求めてみよう。各桁の値・重み・積と分割結果は次のようになる。
\begin{center}
\begin{tabular}{c|cccccccc}
桁&3&1&4&1&5&9&2&6\\
重み&1&2&1&2&1&2&1&2\\ \hline
桁$\times$重み&3&2&4&2&5&18&2&12\\ \hline
分割&3&2&4&2&5&9&2&3\\
\end{tabular}
\end{center}
総和を求めると30となり、剰余は0である。したがって、補数は10になるが、この場合チェックディジットを0とすることとなっているので、最終的に314159260というデータになる。

ここまで見てきてわかる通り、モジュラスの後の数が剰余をとる数、ウェイトの後の数が下の桁からの重みを示す。ISBN13で用いられているモジュラス10ウェイト3・1方式の場合は、下の桁からの重みが3,1の順となり、総和の剰余ならびに補数の基数となるのは10である。

\subsection{チェックサム}
\textbf{チェックサム}\index{ちぇっくさむ@チェックサム}はファイルダウンロード等の場合に特によく使われる手法で、単純にデータ区切り中の一部の数値の合計を別途作成し、この合計値が一致するか否かで誤り検知を行う方法である。例えば、4バイト毎の最後の1バイトの合計などである。

チェックサムは計算が単純ながら検出率がかなり高いため、しばしば使われる。また、この手法がハッシュ関数等後に示す手法の元となっている場合もある。一方、計算が単純であるゆえの欠点として、比較的簡単に数値を合わせることができるため意図的な改竄などには無力である。

\subsection{CRC(巡回冗長検査)}
\textbf{CRC}\index{CRC}(Cyclic Redundancy Check,\textbf{巡回冗長検査}\index{じゅんかいじょうちょうけんさ@巡回冗長検査|see{CRC}})は多項式による除算の剰余を用いて誤り検出を行う手法である。チェックサム以上に偶発的な誤りについての検出精度が高く、また実装や数学的な分析も比較的容易である一方、チェックサムと同じく意図的な改竄には無力である。

CRCでは、元の情報ビット列を除数を示すビット列(通常、各ビットを立てて多項式と見立てて\textbf{生成多項式}\index{せいせいたこうしき@生成多項式}と呼ぶ)で割り、この剰余をとる。ただし、2進数であることと繰り下がりの計算を無視することから、引き算ではなくXOR \footnote{排他的論理和(exclusive or)。二つの集合の一方のみに属するような部分のこと。bitの場合、同じ値のXORは0、異なる値(1と0)のXORは1となる。bit毎のXORは繰り上がりのない二進加算(=繰り下がりのない二進減算)と同じである。}を行う。とった剰余を元の情報ビット列に付加することで一つの情報となる。

例として、USBの通信に出てくるUSBトークンパケット\footnote{続くパケットがINかOUTかを示すなど、通信制御の役割を持つ。}で用いられているCRC-5-USBを見てみよう。

今、10110001という情報が送られるとする。CRC-5-USBの生成多項式は$x^5+x^2+1$、bit列で表すと100101である。除算の筆算の形式（ただし、商と除数は省略)で書けば、
\begin{center}
\begin{tabular}{c|cccccccc}
元の数&1&0&1&1&0&0&0&1\\
最上位からXOR&1&0&0&1&0&1& & \\ \hline
XOR結果& &　&1&0&0&1&0&1\\ 
第3位からXOR& &　&1&0&0&1&0&1\\ \hline
剰余& &　& &　& &　& &0\\ 
\end{tabular}
\end{center}
となり、剰余は0である(通常の除算の筆算と異なり、引き算ではなくXORである点に注意すること。）。CRC-5-USBの生成多項式は5次(=6bit)であるので、その剰余は4次(=5bit)である。したがって、この剰余を00000として、元のデータに付すことでCRC-5-USBによる誤り検出符号付きデータが作成される。

\section{誤り訂正符号}
誤り訂正符号は、誤り検出符号に比べると複雑な手法が多く、その分データ量も増えるなどの難点がある。一方で、再送要求が生じないため、再送要求による負荷が大きいと考えられる場合や特定時間しか使えない回線などでは重宝される手法でもある。

ここでは誤り訂正符号の例として、ハミング距離による訂正符号と、ハミング符号を紹介する。

\subsection{ハミング距離による訂正符号}
情報のうちbitが異なれば1,同じであれば0を加算し、これを全bitについて行った総和を\textbf{ハミング距離}\index{はみんぐきょり@ハミング距離}と呼ぶ。$n$ビットの情報$a,b$の$i$ビット目を$a_i,b_i$と記せばハミング距離$H$は
\begin{equation}
H=\sum^{n}_{i=1} \left(1-\delta_{a_ib_i}\right)
\end{equation}
と書ける。ただし、$\delta_{ij}$はクロネッカーデルタ\footnote{$i$と$j$が同じ場合は1、異なる場合は0を返すという関数。}である。

今、3bitの符号のうち、000,111の2つの符号(ハミング距離が3であるような符号)のみを正しい情報とし、それ以外は利用しない符号であるとする。このとき、3bitに対して最大1bitしか誤らないという仮定をおけば、ある3bitが010になるなど、本来あり得ない値が来た場合にハミング距離が短い側の符号にすることで訂正できる。もちろん、2bit以上の誤りの場合は誤った側に解釈してしまうし、3bit使っていながら2値であるので元のデータよりもかなり大きなデータとなってしまうが、先の仮定が成り立つ状況かつ元データのサイズが小さい場合などに確実で容量も一定の伝送ができるともいえる。

同様に、ハミング距離がある一定値の符号の組を用意してそれ以外は使わず、誤ったデータが来た場合近い側に合わせるという手法で比較的単純な訂正符号となる。

\subsection{ハミング符号}
\textbf{ハミング符号}\index{はみんぐふごう@ハミング符号}は、パリティビットをさらに拡張した方式で、元データのうち選択的に選ばれた何ビットかのパリティビットを複数種用意し、これをデータ末尾に付加することによって誤りの検出のみならず例えば1ビットの訂正を可能にする方法ならびにその符号である。

ハミング符号では、最初、元データの1ブロック(データブロック)とパリティビットを次の手順に従って並べる。
\begin{enumerate}
\item 最初、ビット列が空の状態であると考え、この1bit目から埋めていくとする。
\item ビット列を先頭から順に埋める。以下、現在考えている箇所をハミング符号の第$i$番目とあらわす。
  \begin{itemize}
  \item $i$が$2$の累乗数であるとき、このビットはパリティビットとする。
  \item $i$が$2$の累乗数でないとき、データブロックのまだ取っていないビットのうち、先頭のものをハミング符号に含める。
  \end{itemize}
\item 前項をデータブロックが尽きるまで行う。
\end{enumerate}

この手順に従って、例えばbit列の15bit目までを記述すると表\ref{table7_1}($d$は元データのデータブロック、$p$はパリティビットを示し、各々添え字は何番目かを示す)になる。
\begin{table}[htb]
\centering
\caption{ハミング符号のパリティ決定用bit列 15bit目までのビット内訳}\label{table7_1}
\begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
ビット列の番号&$1$&$2$&$3$&$4$&$5$&$6$&$7$&$8$&$9$&$10$&$11$&$12$&$13$&$14$&$15$\\ \hline
内容&$p_1$&$p_2$&$d_1$&$p_3$&$d_2$&$d_3$&$d_4$&$p_4$&$d_5$&$d_6$&$d_7$&$d_8$&$d_9$&$d_{10}$&$d_{11}$\\ \hline
\end{tabular}
\end{table}

ここで、$i$番目のパリティビット$p_i$は、ビット番号を2進表記したときに$2^{i-1}$の位のビットが立っている箇所のパリティビットの役割を果たす。例えば、$p_2$の場合は、$2$の位のビットが立っている番号ということで、ビット列をベースとして2,3,6,7,10,11,14,15bitでのパリティを指す。このとき、一般にはevenとなるような値がパリティとなる(換言すれば、パリティビット以外の対象ビットの1の個数が奇数なら1、偶数なら0である)。元データで言えば、1,3,4,6,7,10,11bit目のXOR総和が$p_2$となる。この計算によって得られたパリティビットを、先の表\ref{table7_1}に加えた符号全体をハミング符号と呼ぶ。

ハミング符号のある1bitに誤りがあった場合、そのbitの関係する箇所でパリティが合わなくなる。例えば、元データの5bit目(表\ref{table7_1}でわかる通り、ビット列で言うと9番目)に誤りがあった場合、$9_{(10)}=1001_{(2)}$であることから、$p_1$と$p_4$が合わなくなる。1bitの誤りである仮定の下この誤り方は一意に定まるため、何bit目が誤っているか特定・訂正できる。

ハミング符号を付す場合は、パリティビットを$2^m$の単位でつけることから、ブロック長を$2^m-1$とする。この内訳はパリティビットが$m$個、元データが$2^m-1-m$個である。このときのハミング符号をHamming($2^m$,$2^m-1-m$)と記す。例えば、Hamming(7,4)は1ブロック当たり7bit,うちパリティビットが3bitで元データが4bitであるようなハミング符号である。以下、このHamming(7,4)での例を見てみよう。

Hamming(7,4)のパリティビット数は3bitである。表\ref{table7_1}をみてパリティを決定すると
\begin{eqnarray*}
p_1&=&d_1 \oplus d_2 \oplus d_4 \\
p_2&=&d_1 \oplus d_3 \oplus d_4 \\
p_3&=&d_2 \oplus d_3 \oplus d_4 \\
\end{eqnarray*}
である。(ただし、$\oplus$はXOR演算を示す。)例えば元データが1101であった場合、$p_1=1,p_2=0,p_3=0$となり、ハミング符号は1010101となる。

では、これが誤って送られて、例えば1010111と来たとしよう。このとき、先のパリティを計算すると$p_1=1,p_2=1,p_3=1$となり、$p_2,p_3$が異なる。この2つに含まれていて$p_1$に含まれないのは$d_3$であるから、誤っているのは$d_3$と分かり、これを0に訂正することができるのである。

\section*{演習問題}
\begin{problems}
\item Linuxディストリビューションのisoファイルなど、大きなファイルのダウンロードには、md5ファイルという誤り検出用ファイルがしばしば用意されている。これはmd5sumという手法による誤り検出である。この手法について調べ、md5sumのどのような性質がダウンロードの確認に適しているのか説明しなさい。

\item ISBN-10(旧ISBN形式)では、9桁の番号にモジュラス11ウェイト$2\sim 10$方式とも呼ばれるモジュラス・ウェイト型のチェックディジットを付加している。このチェックディジットは次のように計算されている。
\begin{enumerate}[1.]
\item 数値の各桁に、下から2,3,4,$\cdots$,10の重みをかけ、各桁の結果の合計を一括方式で求める。
\item 合計を11で割った剰余を求め、その補数を求める(11からその剰余を引く)。
\item 先に求めた補数が11の場合はチェックディジットは0、10の場合はXとする。それ以外の場合は補数そのものがチェックディジットとなる。チェックディジットを末尾につけて一連の番号とする。
\end{enumerate}
10桁のISBNコードと思われる数字とXからなる列が入力されるとき、これが正しいかどうかを判断するプログラムを作成しなさい。ただし、Xは末尾に限り入力されるものとする。

\item 1バイト毎の後半4ビットを足し合わせるチェックサムを考える。例えば、16進数で$(11 22 33)$というデータであれば、$1+2+3=6$がチェックサムである。今、データ\verb|FE DC BA 98 76 54 32 10|があるとき、これを改ざんして、記した方式のチェックサムで検出できないようなデータを作ってみなさい。また、そのようなデータで、元のデータと一切合致しないようなデータも一例作りなさい。

\item 生成多項式$x+1$(除数11)によるCRCはパリティビットであることを証明しなさい。

\item CRC-4-ITUは生成多項式$x^4+x+1$によるCRCである。このとき、剰余が同じとなるような、同じ長さの別情報を2つ見つけなさい。これが似た情報であるほど誤りやすいといえるが、2つの情報は何ビット異なるか？

\item 4bitでハミング距離が3となるような符号の組を一例あげなさい。この符号ではデータ量がどう増え、またどのような誤りなら訂正できるか？

\item 元データファイル及び加えるパリティビットの数$m$が与えられるとき、元データファイルをHamming($2^m$,$2^m-1-m$)でハミング符号化(Encode)するプログラム(Encoder)ならびに、エンコードデータが与えられるときに、元データを訂正して取り出す(Decode)プログラム(Decoder)を作成しなさい。なお、エンコード時に最終ブロックについてbitの数に端数が出た場合、これには0を付してビット長をそろえなさい。また、Encodeファイルのヘッダとして、最初の1byteをパリティビット数、次の1byteを最終ブロックの元データのビット長(端数のビット数)を付すこととし、デコード用の情報としなさい。

\item （発展問題）bit毎の誤り率を$p$とし、$n-1$bit毎にパリティビットを付加して$n$bit毎にデータが区切られ、このセット$N$個によって送信できる一連のデータがあったとする。このとき、このデータにパリティチェックで検出できない誤りが含まれる確率を$p,n,N$を用いて求めなさい。
\end{problems}
